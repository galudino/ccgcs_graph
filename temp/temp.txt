/* Temporary files go here */

    double angle_to(double x, double y) const;
    double angle_to(const position2D& p) const;
    double angle_to(std::array<double, 2>& arr) const;


/**
 *  @brief
 *
 *  @param[in]  x
 *  @param[in]  y
 *
 *  @return
 */
double position2D::angle_to(double x, double y) const {
    double hypotenuse = distance_to(x, y);
    double dx = 0.0;
    double dy = 0.0;
    double opposite = 0.0;


    return std::asin(opposite / hypotenuse);
}

/**
 *  @brief
 *
 *  @param[in]  p
 *
 *  @return
 */
double position2D::angle_to(const position2D& p) const {
    double hypotenuse = distance_to(p);

    double dx = p.m_x - m_x;
    double dy = p.m_y - m_y;

    double result = 0.0;

    if (dx > 0.0 && dy > 0.0) {
        // +x, +y
        result = std::asin(dy / hypotenuse);
    } else if (dx > 0.0 && dy < 0.0) {
        // +x, -y
        result = std::acos(dx / hypotenuse);
    } else if (dx < 0.0 && dy > 0.0) {
        // -x, +y
        result = std::asin(dy / hypotenuse);
    } else if (dx < 0.0 && dy < 0.0) {
        // -x, -y
        result = std::acos(dy / hypotenuse);
    }

    return result;
}

/**
 *  @brief
 *
 *  @param[in]  arr
 *
 *  @return
 */
double position2D::angle_to(std::array<double, 2>& arr) const {
    double hypotenuse = distance_to(arr);

    return 0.0;
}

/*
namespace gcs {
template <typename edge_type> class edge;
template <typename edge_type> std::ostream& operator<<(std::ostream& os, const gcs::edge<edge_type>& e);
}

template <typename edge_type>
class gcs::edge {
public:
    edge();
    edge(int parent_id, int child_id);
    edge(int parent_id, int child_id, edge_type& val);
    edge(const edge& e);
    ~edge();

    edge_type value() const;

    int parent_id() const;
    int child_id() const;

    double weight() const;
    
    void set_value(const edge_type& val);

    void set_parent_id(int parent_id);
    void set_child_id(int child_id);

    void set_weight(double weight);

private:
    edge_type m_val;

    int m_parent_id;
    int m_child_id;

    double m_weight;
};

#include "edge_impl.hpp"

namespace gcs {
template <typename node_type> class node;
template <typename node_type> std::ostream& operator<<(std::ostream& os, const gcs::node<node_type>& n);
}

template <typename node_type, typename edge_type>
class gcs::node {
public:
    using EdgeVector = std::vector<edge<edge_type>>;

    node();
    node(node_type& val, position& pos);
    node(node_type& val, int id, position& pos);
    node(node_type& val);
    node(position& pos);
    node(const node& n);
    ~node();

    node_type value() const;
    EdgeVector edges();
    int id() const;
    position pos();

    void set_value(const node_type& val);
    bool set_id(int id);
    bool set_position(const position& pos);

    bool connect_to(const node& n, bool directed = false);
    bool connect_to(const node& n, edge_type& edge_val, bool directed = false);
private:
    node_type m_val;
    EdgeVector m_edges;

    int m_id;
    position m_pos;
};

Node n1("this node", 0, position(1, 2, 3));
Node n2("that node", 1, position(4, 5, 6)));

// an edge object is created, it's parent id is n1
// it's child id is n2.
// since this edge is directed, only n1 gets
// the edge object pushed to its EdgeVector,
// but n2 will not get this edge object.

// so if we have access to n1,
// we get to n2 by seeing n1's EdgeVector.
// we see that n1 connects to n2
// via parent and child fields, so we get the child id
// and use that to find n2, via a node lookup by id.`n1.connect_to(n2, "EDGE DATA", true);



namespace gcs {

}
// Node is node<node_type>
template <typename node_type>
struct node {
    node_type m_val;
    int m_id;
    position m_pos;
};

// Edge is edge<edge_type>
template <typename node_type, typename edge_type>
struct edge {
    node<node_type>* m_parent;
    node<node_type>* m_child;

    edge_type m_val;
    double m_cost;
};

template <typename node_type, typename edge_type>
struct graph {
    using Node = node<node_type>;
    using Edge = edge<edge_type>;

    using EdgeList = std::vector<Edge>;

    std::map<Node, EdgeList> G;
};

g.add_edge("Node U", "Node V", "Edge UV", edge_cost);
g.add_edge(node_u, node_v, edge_val, edge_cost);
*/
